name: release-supply-chain

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      runner:
        description: Runner target (default uses GitHub-hosted runner)
        required: false
        default: github-hosted
        type: choice
        options:
          - github-hosted
          - self-hosted
      enable_local_sync:
        description: Sync image to localhost:5001 (only relevant for self-hosted)
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  packages: write
  id-token: write
  attestations: write

jobs:
  build-sign-attest:
    runs-on: ${{ github.event_name == 'workflow_dispatch' && inputs.runner == 'self-hosted' && 'self-hosted' || 'ubuntu-latest' }}
    env:
      IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/secure-gitops-demo-app
      ENABLE_LOCAL_SYNC: ${{ github.event_name == 'workflow_dispatch' && inputs.enable_local_sync && 'true' || 'false' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure Linux runner
        if: runner.os != 'Linux'
        run: |
          echo "This workflow requires a Linux runner. Current runner OS: ${RUNNER_OS}"
          exit 1

      - name: Install toolchain
        run: |
          set -euo pipefail
          BIN_DIR="${RUNNER_TEMP}/bin"
          mkdir -p "${BIN_DIR}"
          echo "${BIN_DIR}" >> "$GITHUB_PATH"

          CRANE_VERSION=v0.20.3
          curl -fsSL -o "${RUNNER_TEMP}/go-containerregistry.tgz" \
            "https://github.com/google/go-containerregistry/releases/download/${CRANE_VERSION}/go-containerregistry_Linux_x86_64.tar.gz"
          tar -xzf "${RUNNER_TEMP}/go-containerregistry.tgz" -C "${BIN_DIR}" crane

          SYFT_VERSION=v1.13.0
          curl -fsSL -o "${RUNNER_TEMP}/syft.tgz" \
            "https://github.com/anchore/syft/releases/download/${SYFT_VERSION}/syft_${SYFT_VERSION#v}_linux_amd64.tar.gz"
          tar -xzf "${RUNNER_TEMP}/syft.tgz" -C "${BIN_DIR}" syft

          GRYPE_VERSION=v0.83.0
          curl -fsSL -o "${RUNNER_TEMP}/grype.tgz" \
            "https://github.com/anchore/grype/releases/download/${GRYPE_VERSION}/grype_${GRYPE_VERSION#v}_linux_amd64.tar.gz"
          tar -xzf "${RUNNER_TEMP}/grype.tgz" -C "${BIN_DIR}" grype

          TRIVY_VERSION=v0.56.2
          curl -fsSL -o "${RUNNER_TEMP}/trivy.tgz" \
            "https://github.com/aquasecurity/trivy/releases/download/${TRIVY_VERSION}/trivy_${TRIVY_VERSION#v}_Linux-64bit.tar.gz"
          tar -xzf "${RUNNER_TEMP}/trivy.tgz" -C "${BIN_DIR}" trivy

          COSIGN_VERSION=v2.4.1
          curl -fsSL -o "${BIN_DIR}/cosign" \
            "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64"
          chmod +x "${BIN_DIR}/cosign"

      - name: Verify required tools
        run: |
          set -euo pipefail
          for tool in docker crane syft grype trivy cosign jq; do
            if ! command -v "$tool" >/dev/null 2>&1; then
              echo "required tool not found: $tool"
              exit 1
            fi
          done

      - name: Login to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Build and push image
        id: image
        run: |
          set -euo pipefail
          IMAGE_TAG="${GITHUB_SHA::12}"
          IMAGE_REF="${IMAGE_NAME}:${IMAGE_TAG}"
          docker build -t "${IMAGE_REF}" supply-chain/demo-app
          docker push "${IMAGE_REF}"
          DIGEST="$(crane digest "${IMAGE_REF}")"
          echo "image_ref=${IMAGE_NAME}@${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "image_digest=${DIGEST}" >> "$GITHUB_OUTPUT"

      - name: Generate SBOM (Syft)
        run: syft "${{ steps.image.outputs.image_ref }}" -o spdx-json=sbom.spdx.json

      - name: Scan image (Grype)
        run: grype "${{ steps.image.outputs.image_ref }}" --fail-on high -o json > grype.json

      - name: Scan image (Trivy)
        run: trivy image --format json --output trivy.json --exit-code 1 --severity HIGH,CRITICAL "${{ steps.image.outputs.image_ref }}"

      - name: Prepare signing context
        run: |
          set -euo pipefail
          if [[ -n "${COSIGN_PRIVATE_KEY:-}" ]]; then
            printf '%s\n' "$COSIGN_PRIVATE_KEY" > cosign.key
            chmod 600 cosign.key
            echo "SIGNING_MODE=key" >> "$GITHUB_ENV"
          elif [[ -n "${VAULT_ADDR:-}" && -n "${VAULT_TOKEN:-}" ]]; then
            if command -v vault >/dev/null 2>&1; then
              vault login "$VAULT_TOKEN" >/dev/null
              vault kv get -field=private_key kv/cicd/cosign > cosign.key
              chmod 600 cosign.key
              echo "SIGNING_MODE=key" >> "$GITHUB_ENV"
            else
              echo "Vault credentials provided but vault CLI is unavailable; falling back to keyless signing."
              echo "SIGNING_MODE=keyless" >> "$GITHUB_ENV"
            fi
          else
            echo "No signing key configured; using keyless signing with GitHub OIDC."
            echo "SIGNING_MODE=keyless" >> "$GITHUB_ENV"
          fi
        env:
          VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
          VAULT_TOKEN: ${{ secrets.VAULT_TOKEN }}
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}

      - name: Sign image (Cosign)
        run: |
          set -euo pipefail
          if [[ "${SIGNING_MODE}" == "key" ]]; then
            cosign sign --yes --tlog-upload=false --key cosign.key "${{ steps.image.outputs.image_ref }}"
          else
            cosign sign --yes "${{ steps.image.outputs.image_ref }}"
          fi

      - name: Generate provenance predicate
        run: |
          set -euo pipefail
          cp supply-chain/attestations/slsa-provenance-template.json provenance.json
          sed -i "s#IMAGE_REF#${{ steps.image.outputs.image_ref }}#g" provenance.json
          sed -i "s#IMAGE_DIGEST#${{ steps.image.outputs.image_digest }}#g" provenance.json
          sed -i "s#GIT_SHA#${GITHUB_SHA}#g" provenance.json
          sed -i "s#OWNER/REPO#${GITHUB_REPOSITORY}#g" provenance.json

      - name: Attach SBOM attestation
        run: |
          set -euo pipefail
          if [[ "${SIGNING_MODE}" == "key" ]]; then
            cosign attest --yes --tlog-upload=false --key cosign.key --predicate sbom.spdx.json --type spdx "${{ steps.image.outputs.image_ref }}"
          else
            cosign attest --yes --predicate sbom.spdx.json --type spdx "${{ steps.image.outputs.image_ref }}"
          fi

      - name: Attach SLSA attestation
        run: |
          set -euo pipefail
          if [[ "${SIGNING_MODE}" == "key" ]]; then
            cosign attest --yes --tlog-upload=false --key cosign.key --predicate provenance.json --type https://slsa.dev/provenance/v1 "${{ steps.image.outputs.image_ref }}"
          else
            cosign attest --yes --predicate provenance.json --type https://slsa.dev/provenance/v1 "${{ steps.image.outputs.image_ref }}"
          fi

      - name: Export image metadata
        run: |
          set -euo pipefail
          printf '%s\n' "${{ steps.image.outputs.image_ref }}" > image-ref.txt
          printf '%s\n' "${{ steps.image.outputs.image_digest }}" > image-digest.txt

      - name: Verify signature and attestations (Cosign)
        run: |
          set -euo pipefail
          if [[ "${SIGNING_MODE}" == "key" ]]; then
            cosign public-key --key cosign.key > cosign.pub
            cosign verify --key cosign.pub "${{ steps.image.outputs.image_ref }}" > cosign-verify-signature.txt
            cosign verify-attestation --key cosign.pub --type spdx "${{ steps.image.outputs.image_ref }}" > cosign-verify-attestation-spdx.txt
            cosign verify-attestation --key cosign.pub --type https://slsa.dev/provenance/v1 "${{ steps.image.outputs.image_ref }}" > cosign-verify-attestation-slsa.txt
          else
            printf '%s\n' "KEYLESS (OIDC)" > cosign.pub
            IDENTITY_REGEX="^https://github.com/${GITHUB_REPOSITORY}/.github/workflows/release.yml@.*$"
            ISSUER="https://token.actions.githubusercontent.com"
            cosign verify \
              --certificate-oidc-issuer "${ISSUER}" \
              --certificate-identity-regexp "${IDENTITY_REGEX}" \
              "${{ steps.image.outputs.image_ref }}" > cosign-verify-signature.txt
            cosign verify-attestation \
              --certificate-oidc-issuer "${ISSUER}" \
              --certificate-identity-regexp "${IDENTITY_REGEX}" \
              --type spdx "${{ steps.image.outputs.image_ref }}" > cosign-verify-attestation-spdx.txt
            cosign verify-attestation \
              --certificate-oidc-issuer "${ISSUER}" \
              --certificate-identity-regexp "${IDENTITY_REGEX}" \
              --type https://slsa.dev/provenance/v1 "${{ steps.image.outputs.image_ref }}" > cosign-verify-attestation-slsa.txt
          fi

      - name: Optional local registry sync
        run: |
          if [[ "${ENABLE_LOCAL_SYNC}" == "true" ]]; then
            ./scripts/sync-image-to-local-registry.sh "${{ steps.image.outputs.image_ref }}" localhost:5001
          else
            echo "Skipping local registry sync (ENABLE_LOCAL_SYNC=${ENABLE_LOCAL_SYNC})."
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: supply-chain-artifacts
          path: |
            sbom.spdx.json
            provenance.json
            grype.json
            trivy.json
            image-ref.txt
            image-digest.txt
            cosign.pub
            cosign-verify-signature.txt
            cosign-verify-attestation-spdx.txt
            cosign-verify-attestation-slsa.txt
